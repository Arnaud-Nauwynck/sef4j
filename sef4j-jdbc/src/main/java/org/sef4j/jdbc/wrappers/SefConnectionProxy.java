package org.sef4j.jdbc.wrappers;

import java.sql.Array;
import java.sql.Blob;
import java.sql.CallableStatement;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.NClob;
import java.sql.PreparedStatement;
import java.sql.SQLClientInfoException;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Savepoint;
import java.sql.Statement;
import java.sql.Struct;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;

import org.sef4j.callstack.CallStackElt.StackPopper;
import org.sef4j.callstack.LocalCallStack;

/**
 * java.sql.Connection proxy instrumented for using LocalCallStack.push()/pop()
 *
 * design pattern:
 *  - Bridge/Proxy to java.sql.Connection
 *  - factory of Sef4JStatement / Sef4JPreparedStatement / Sef4JCallableStatement
 *      (replacement for sql.Statement / sql.PreparedStatement / sql.CallableStatement)
 *
 */
public class SefConnectionProxy implements Connection {

    /** underlying for proxy */
    private final Connection to;
	
    private int connId;
    
    // constructor
    // ------------------------------------------------------------------------
        
    public SefConnectionProxy(Connection to) {
        this(to, -1);
    }
    
    public SefConnectionProxy(Connection to, int connId) {
        this.to = to;
        this.connId = connId;
    }

    // ------------------------------------------------------------------------
    
    public Connection getUnderlyingConnection() {
        return to;
    }

    public int getUnderlyingConnectionId() {
        return connId;
    }


    // implements java.sql.Connection
    // create sub Statement/PreparedStatment... => create real statement + wrap in logger   
    // ------------------------------------------------------------------------

    public Statement createStatement() throws SQLException {
        Statement p = to.createStatement();
        return new SefStatementProxy(this, p);
    }

    public PreparedStatement prepareStatement(String sql) throws SQLException {
        PreparedStatement p = to.prepareStatement(sql);
        return new SefPreparedStatementProxy(this, p, sql);
    }

    public CallableStatement prepareCall(String sql) throws SQLException {
        CallableStatement p = to.prepareCall(sql);
        return new SefCallableStatementProxy(this, p, sql);
    }

    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        Statement p = to.createStatement(resultSetType, resultSetConcurrency);
        return new SefStatementProxy(this, p, resultSetType, resultSetConcurrency);
    }

    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        PreparedStatement p = to.prepareStatement(sql, resultSetType, resultSetConcurrency);
        return new SefPreparedStatementProxy(this, p, sql, resultSetType, resultSetConcurrency);
    }

    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        CallableStatement p = to.prepareCall(sql, resultSetType, resultSetConcurrency);
        return new SefCallableStatementProxy(this, p, sql, resultSetType, resultSetConcurrency);
    }

    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        Statement p = to.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
        return new SefStatementProxy(this, p, resultSetType, resultSetConcurrency); // TODO, resultSetHoldability;
    }

    public CallableStatement prepareCall(String sql,
                                         int resultSetType,
                                         int resultSetConcurrency,
                                         int resultSetHoldability) throws SQLException {
        CallableStatement stmt = to.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
        return new SefCallableStatementProxy(this, stmt, sql, resultSetType, resultSetConcurrency);
    }

    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        PreparedStatement stmt = to.prepareStatement(sql, autoGeneratedKeys);
        return new SefPreparedStatementProxy(this, stmt, sql);
    }

    public PreparedStatement prepareStatement(String sql,
                                              int resultSetType,
                                              int resultSetConcurrency,
                                              int resultSetHoldability) throws SQLException {
        PreparedStatement stmt = to.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
        return new SefPreparedStatementProxy(this, stmt, sql, resultSetType, resultSetConcurrency); // TODO resultSetHoldability;
    }

    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        PreparedStatement stmt = to.prepareStatement(sql, columnIndexes);
        return new SefPreparedStatementProxy(this, stmt, sql);
    }

    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        PreparedStatement stmt = to.prepareStatement(sql, columnNames);
        return new SefPreparedStatementProxy(this, stmt, sql);
    }

    // implements java.sql.Connection : delegate to underlying connection + log pre/post 
    // ------------------------------------------------------------------------

    public String nativeSQL(String sql) throws SQLException {
        StackPopper toPop = LocalCallStack.meth("nativeSQL").withParam("sql", sql).push();
        try {
            String res = to.nativeSQL(sql);
            
            return LocalCallStack.pushPopParentReturn(res);
        } catch(SQLException ex) {
            throw LocalCallStack.pushPopParentException(ex);
        } finally {
            toPop.close();
        }
    }

    public void setAutoCommit(boolean autoCommit) throws SQLException {
        // distinguish true/false as pseudo method name for stats
        String pseudoMeth = (autoCommit)? "setAutoCommit_true" : "setAutoCommit_false";
        StackPopper toPop = LocalCallStack.meth(pseudoMeth).push();
        try {
            to.setAutoCommit(autoCommit);
            
            // LocalCallStack.pushPopParentReturn();
        } catch(SQLException ex) {
            throw LocalCallStack.pushPopParentException(ex);
        } finally {
            toPop.close();
        }
    }

    public boolean getAutoCommit() throws SQLException {
        return to.getAutoCommit();
    }

    public static String transactionLevelToString(int level) {
        switch(level) {
        case Connection.TRANSACTION_NONE: return "NONE";
        case Connection.TRANSACTION_READ_UNCOMMITTED: return "READ_COMMITTED";
        case Connection.TRANSACTION_REPEATABLE_READ: return "REPEATABLE_READ";
        case Connection.TRANSACTION_SERIALIZABLE: return "SERIALIZABLE";
        default: return "UNKOWN";
        }
    }
        
    public void setTransactionIsolation(int level) throws SQLException {
        String pseudoMeth = "setTransactionIsolation_" + transactionLevelToString(level);
        StackPopper toPop = LocalCallStack.meth(pseudoMeth).push();
        try {
            to.setTransactionIsolation(level);
            
            // LocalCallStack.pushPopParentReturn();
        } catch(SQLException ex) {
            throw LocalCallStack.pushPopParentException(ex);
        } finally {
            toPop.close();
        }
    }

    public int getTransactionIsolation() throws SQLException {
        return to.getTransactionIsolation();
    }

    public void commit() throws SQLException {
        boolean isLog = isLogCommits();
        boolean doSleep = hasMatchingSleepCommit();
        if (sleepMillisBeforeCommit > 0 && doSleep) {
            try {
                Thread.sleep(sleepMillisBeforeCommit);
            } catch (Exception ex) {
            }
        }
        if (isLog) {
            String methodMsg = "commit";
            if (sleepMillisBeforeCommit > 0 && doSleep) {
                methodMsg = "sleep-before" + sleepMillisBeforeCommit + " + " + methodMsg;
            }
            if (sleepMillisAfterCommit > 0 && doSleep) {
                methodMsg = methodMsg + " + sleep-after " + sleepMillisAfterCommit;
            }
            callInfoLogger.pre(methodMsg, "commit");
        }

        try {
            to.commit();

            resetCount();
            if (isLog) {
                callInfoLogger.postVoid();
            }
        } catch (SQLException ex) {
            callInfoLogger.postEx(ex);
            throw ex;
        }

        if (sleepMillisAfterCommit > 0 && doSleep) {
            try {
                Thread.sleep(sleepMillisAfterCommit);
            } catch (Exception ex) {
            }
        }
    }

    public void rollback() throws SQLException {
        boolean isLog = isLogCommits();
        if (isLog) {
            callInfoLogger.pre("rollback", "rollback");
        }
        try {
            to.rollback();

            resetCount();
            if (isLog) {
                callInfoLogger.postVoid();
            }
        } catch (SQLException ex) {
            callInfoLogger.postEx(ex);
            throw ex;
        }
    }

    public void releaseSavepoint(Savepoint savepoint) throws SQLException {
        boolean isLog = isLogCommits();
        if (isLog) {
            callInfoLogger.pre("releaseSavepoint", "" + savepoint);
        }
        try {
            to.releaseSavepoint(savepoint);
            if (isLog) {
                callInfoLogger.postVoid();
            }
        } catch (SQLException ex) {
            callInfoLogger.postEx(ex);
            throw ex;
        }
    }

    public void rollback(Savepoint savepoint) throws SQLException {
        boolean isLog = isLogCommits();
        if (isLog) {
            callInfoLogger.pre("rollback", "" + savepoint);
        }
        try {
            to.rollback(savepoint);

            // TODO .. handle counter in savepoint
            resetCount();
            if (isLog) {
                callInfoLogger.postVoid();
            }
        } catch (SQLException ex) {
            callInfoLogger.postEx(ex);
            throw ex;
        }
    }

    public Savepoint setSavepoint() throws SQLException {
        boolean isLog = isLogCommits();
        if (isLog) {
            callInfoLogger.pre("setSavepoint", "");
        }
        try {
            Savepoint res = to.setSavepoint();
            // TODO .. handle counter in savepoint
            if (isLog) {
                callInfoLogger.postRes(res);
            }
            return res;
        } catch (SQLException ex) {
            callInfoLogger.postEx(ex);
            throw ex;
        }
    }

    public Savepoint setSavepoint(String name) throws SQLException {
        boolean isLog = isLogCommits();
        if (isLog) {
            callInfoLogger.pre("setSavepoint", name);
        }
        try {
            Savepoint res = to.setSavepoint(name);
            // TODO .. handle counter in savepoint
            if (isLog) {
                callInfoLogger.postRes(res);
            }
            return res;
        } catch (SQLException ex) {
            callInfoLogger.postEx(ex);
            throw ex;
        }
    }

    public void setReadOnly(boolean readOnly) throws SQLException {
    	boolean isLog = isLogCommits();
        if (isLog) {
        	callInfoLogger.pre("setReadOnly", "" + readOnly);
        }
        try {
            to.setReadOnly(readOnly);
            if (isLog) {
            	callInfoLogger.postVoid();
            }
        } catch (SQLException ex) {
            if (isLog) {
            	callInfoLogger.postEx(ex);
            }
            throw ex;
        }
    }

    public boolean isReadOnly() throws SQLException {
        return to.isReadOnly();
    }

    public void close() throws SQLException {
        owner.onCloseConn(this);
        to.close();
    }

    public boolean isClosed() throws SQLException {
        boolean res = to.isClosed();
        return res;
    }

    public DatabaseMetaData getMetaData() throws SQLException {
        return to.getMetaData();
    }

    public void setCatalog(String catalog) throws SQLException {
        to.setCatalog(catalog);
    }

    public String getCatalog() throws SQLException {
        return to.getCatalog();
    }

    public SQLWarning getWarnings() throws SQLException {
        return to.getWarnings();
    }

    public void clearWarnings() throws SQLException {
        to.clearWarnings();
    }

    public Map getTypeMap() throws SQLException {
        return to.getTypeMap();
    }

    public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
        to.setTypeMap(map);
    }

    public int getHoldability() throws SQLException {
        return to.getHoldability();
    }

    public void setHoldability(int holdability) throws SQLException {
        boolean isLog = isLogCommits();
        if (isLog) {
            callInfoLogger.pre("setHoldability", "" + holdability);
        }
        try {
            to.setHoldability(holdability);
            if (isLog) {
                callInfoLogger.postVoid();
            }
        } catch (SQLException ex) {
            callInfoLogger.postEx(ex);
            throw ex;
        }
    }


    public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
        return to.createArrayOf(typeName, elements);
    }

    public Blob createBlob() throws SQLException {
        return to.createBlob();
    }

    public Clob createClob() throws SQLException {
        return to.createClob();
    }

    public NClob createNClob() throws SQLException {
        return to.createNClob();
    }

    public SQLXML createSQLXML() throws SQLException {
        return to.createSQLXML();
    }

    public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
        return to.createStruct(typeName, attributes);
    }

    public Properties getClientInfo() throws SQLException {
        return to.getClientInfo();
    }

    public String getClientInfo(String name) throws SQLException {
        return to.getClientInfo(name);
    }

    public void setClientInfo(Properties properties) throws SQLClientInfoException {
        to.setClientInfo(properties);
    }

    public void setClientInfo(String name, String value) throws SQLClientInfoException {
        to.setClientInfo(name, value);        
    }

    public boolean isValid(int timeout) throws SQLException {
        return isValid(timeout);
    }
    
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return to.isWrapperFor(iface);
    }

    public <T> T unwrap(Class<T> iface) throws SQLException {
        return to.unwrap(iface);
    }


    public void setSchema(String schema) throws SQLException {
        to.setSchema(schema);
    }

    public String getSchema() throws SQLException {
        return to.getSchema();
    }

    public void abort(Executor executor) throws SQLException {
        to.abort(executor);
    }

    public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
        to.setNetworkTimeout(executor, milliseconds);
    }

    public int getNetworkTimeout() throws SQLException {
        return to.getNetworkTimeout();
    }
    

    // override Object
    // ------------------------------------------------------------------------

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || !(obj instanceof SefConnectionProxy))
            return false;
        SefConnectionProxy o = (SefConnectionProxy) obj;
        return to.equals(o.to);
    }
    
    @Override
    public String toString() {
        return "SefWrappedConnection[" + connId + "]";
    }
    
}
